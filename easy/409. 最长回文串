给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。

/*
  下面的解法应该是次优雅的方式之一了，就是在统计每个字符出现的过程当中进行回文串计数，
  任意两个字符相同，就可以组成一个回文对，所以一旦一个字符每次出现了偶数次，就相当于有两个字符匹配，因此加2
  如果有字符出现奇数次，那么结果的长度一定小于s的长度，出现奇数次的字符有一次机会放中间，因此加1
*/


class Solution {
private:
    unordered_map<int, int> M;
    
public:
    int longestPalindrome(string s) {
        int ans = 0;
        for(int i = 0; i < s.size(); i++){
            M[s[i]] ++;
            if(M[s[i]] % 2 == 0) ans +=2;
        }
       if(ans < s.size()) ans += 1;
       return ans;
    }
};
